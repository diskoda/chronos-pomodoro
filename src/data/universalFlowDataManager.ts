import type { QuestionFlowData } from '../components/questionFlow/core/types';

// ==========================================
// SISTEMA DE GERENCIAMENTO DE DADOS DE FLUXO UNIVERSAL
// ==========================================

interface FlowDataRegistry {
  [questionId: number]: QuestionFlowData;
}

class UniversalFlowDataManager {
  private registry: FlowDataRegistry = {};
  private loadedSources: Set<string> = new Set();

  /**
   * Registrar dados de fluxo para uma quest√£o
   */
  registerFlowData(questionId: number, data: QuestionFlowData): void {
    this.registry[questionId] = data;
  }

  /**
   * Buscar dados de fluxo por ID da quest√£o
   */
  getFlowData(questionId: number): QuestionFlowData | null {
    return this.registry[questionId] || null;
  }

  /**
   * Verificar se uma quest√£o tem dados de fluxo
   */
  hasFlowData(questionId: number): boolean {
    return questionId in this.registry;
  }

  /**
   * Carregar dados de m√∫ltiplas quest√µes de uma fonte
   */
  loadFromSource(sourceName: string, dataLoader: () => Promise<FlowDataRegistry> | FlowDataRegistry): Promise<void> {
    if (this.loadedSources.has(sourceName)) {
      return Promise.resolve();
    }

    const loadData = async () => {
      try {
        const data = await dataLoader();
        Object.entries(data).forEach(([questionId, flowData]) => {
          this.registerFlowData(parseInt(questionId), flowData);
        });
        this.loadedSources.add(sourceName);
      } catch (error) {
        throw error;
      }
    };

    return loadData();
  }

  /**
   * Gerar dados de fluxo automaticamente a partir de uma quest√£o
   */
  generateBasicFlowData(question: any): QuestionFlowData {
    const { title, category, alternatives } = question;

    // Tentar determinar a alternativa correta (placeholder - seria melhor ter isso nos dados)
    const correctAlternative = 'A'; // Por padr√£o, assumir A como correta

    const alternativesAnalysis = alternatives?.map((alt: string, index: number) => {
      const letter = String.fromCharCode(65 + index); // A, B, C, D...
      const text = alt.replace(/^\([A-Z]\)\s*/, ''); // Remove "(A) " do in√≠cio
      
      return {
        letter,
        text,
        isCorrect: letter === correctAlternative,
        explanation: letter === correctAlternative 
          ? `Esta √© a alternativa correta. An√°lise detalhada: ${text}`
          : `Esta alternativa est√° incorreta. Explica√ß√£o: an√°lise pendente para ${text}`,
        category: letter === correctAlternative ? 'correct' : 'incorrect',
        conceptsInvolved: [category.toLowerCase().replace(/\s+/g, '-')]
      };
    }) || [];

    return {
      contextText: `Esta quest√£o aborda conceitos importantes de ${category}. 
        
Analise cuidadosamente o enunciado e as alternativas apresentadas. 
O objetivo √© aplicar o conhecimento te√≥rico na pr√°tica cl√≠nica, 
considerando evid√™ncias cient√≠ficas atuais.

Lembre-se: cada alternativa deve ser avaliada criteriosamente, 
pois na medicina, detalhes fazem toda a diferen√ßa no cuidado ao paciente.`,

      explanationText: `Para resolver esta quest√£o de ${category}, √© importante considerar:

**Conceitos fundamentais:**

1. **Contexto cl√≠nico**: Analise todas as informa√ß√µes fornecidas no caso
2. **Base cient√≠fica**: Aplique conhecimentos baseados em evid√™ncias
3. **Racioc√≠nio l√≥gico**: Elimine alternativas inadequadas sistematicamente
4. **Pr√°tica cl√≠nica**: Considere a viabilidade e seguran√ßa das op√ß√µes

**Abordagem recomendada:**
- Leia o enunciado identificando pontos-chave
- Relembre conceitos te√≥ricos relacionados
- Analise cada alternativa individualmente
- Compare as op√ß√µes e identifique a mais adequada

O dom√≠nio destes conceitos √© essencial para a pr√°tica cl√≠nica segura e eficaz.`,

      alternativesAnalysis,

      metadata: {
        specialty: Array.isArray(category) ? category[0] : category,
        difficulty: 'medium',
        tags: [title.toLowerCase().replace(/\s+/g, '-'), category.toLowerCase()],
        estimatedTime: 5,
        conceptsRequired: ['racioc√≠nio cl√≠nico', 'conhecimento te√≥rico'],
        learningObjectives: [
          `Aplicar conceitos de ${category}`,
          'Desenvolver racioc√≠nio cl√≠nico',
          'Analisar alternativas sistematicamente'
        ]
      }
    };
  }

  /**
   * Listar todas as quest√µes com dados de fluxo
   */
  listAvailableQuestions(): number[] {
    return Object.keys(this.registry).map(id => parseInt(id));
  }

  /**
   * Estat√≠sticas do registry
   */
  getStats(): {
    totalQuestions: number;
    loadedSources: string[];
    autoGenerated: number;
    manual: number;
  } {
    const totalQuestions = Object.keys(this.registry).length;
    const autoGenerated = Object.values(this.registry)
      .filter(data => data.contextText?.includes('Esta quest√£o aborda conceitos importantes')).length;
    
    return {
      totalQuestions,
      loadedSources: Array.from(this.loadedSources),
      autoGenerated,
      manual: totalQuestions - autoGenerated
    };
  }

  /**
   * Validar dados de fluxo
   */
  validateFlowData(data: QuestionFlowData): { isValid: boolean; errors: string[] } {
    const errors: string[] = [];

    if (!data.contextText?.trim()) {
      errors.push('contextText √© obrigat√≥rio');
    }

    if (!data.explanationText?.trim()) {
      errors.push('explanationText √© obrigat√≥rio');
    }

    if (!data.alternativesAnalysis?.length) {
      errors.push('alternativesAnalysis deve ter pelo menos uma alternativa');
    } else {
      const correctCount = data.alternativesAnalysis.filter(alt => alt.isCorrect).length;
      if (correctCount !== 1) {
        errors.push('Deve haver exatamente uma alternativa correta');
      }

      data.alternativesAnalysis.forEach((alt, index) => {
        if (!alt.letter || !alt.text || !alt.explanation) {
          errors.push(`Alternativa ${index + 1}: letter, text e explanation s√£o obrigat√≥rios`);
        }
      });
    }

    return {
      isValid: errors.length === 0,
      errors
    };
  }

  /**
   * Exportar todos os dados para backup
   */
  exportData(): FlowDataRegistry {
    return { ...this.registry };
  }

  /**
   * Importar dados de backup
   */
  importData(data: FlowDataRegistry): void {
    Object.entries(data).forEach(([questionId, flowData]) => {
      this.registerFlowData(parseInt(questionId), flowData);
    });
  }

  /**
   * Limpar registry (√∫til para testes)
   */
  clear(): void {
    this.registry = {};
    this.loadedSources.clear();
  }
}

// ==========================================
// INST√ÇNCIA SINGLETON E FUN√á√ïES DE CONVENI√äNCIA
// ==========================================

export const flowDataManager = new UniversalFlowDataManager();

// Fun√ß√µes de conveni√™ncia para compatibilidade
export function getQuestionFlowData(questionId: number): QuestionFlowData | null {
  // Primeiro, tentar buscar dados manuais
  let flowData = flowDataManager.getFlowData(questionId);
  
  // Se n√£o encontrar, tentar gerar automaticamente
  if (!flowData) {
    console.log(`üîÑ Gerando dados de fluxo automaticamente para quest√£o ${questionId}`);
    // TODO: Buscar dados da quest√£o para gerar flowData
    // Por enquanto, retornar null se n√£o encontrar
  }
  
  return flowData;
}

export function registerQuestionFlowData(questionId: number, data: QuestionFlowData): void {
  flowDataManager.registerFlowData(questionId, data);
}

export function hasQuestionFlowData(questionId: number): boolean {
  return flowDataManager.hasFlowData(questionId);
}

// ==========================================
// CARREGADORES DE DADOS POR FONTE
// ==========================================

/**
 * Carregar dados das quest√µes USP-SP 2025
 */
export async function loadUSPSP2025FlowData(): Promise<void> {
  return flowDataManager.loadFromSource('usp-sp-2025', async () => {
    // Importar dados da quest√£o 1 (j√° existe)
    const { question1FlowData } = await import('./enhancedQuestionFlowData');
    
    return {
      1: question1FlowData
      // TODO: Adicionar outras quest√µes conforme forem criadas
    };
  });
}

/**
 * Carregar dados auto-gerados para quest√µes sem dados manuais
 */
export async function loadAutoGeneratedFlowData(questions: any[]): Promise<void> {
  return flowDataManager.loadFromSource('auto-generated', () => {
    const autoData: FlowDataRegistry = {};
    
    questions.forEach(question => {
      if (!flowDataManager.hasFlowData(question.id)) {
        autoData[question.id] = flowDataManager.generateBasicFlowData(question);
      }
    });
    
    return autoData;
  });
}

// ==========================================
// INICIALIZA√á√ÉO AUTOM√ÅTICA
// ==========================================

/**
 * Inicializar sistema de dados de fluxo
 */
export async function initializeFlowDataSystem(questions?: any[]): Promise<void> {
  try {
    // Carregar dados manuais existentes
    await loadUSPSP2025FlowData();
    
    // Gerar dados autom√°ticos para quest√µes sem dados manuais (se fornecidas)
    if (questions?.length) {
      await loadAutoGeneratedFlowData(questions);
    }
    
  } catch (error) {
    throw error;
  }
}

// ==========================================
// HOOKS PARA REACT (OPCIONAL)
// ==========================================

import { useState, useEffect } from 'react';

export function useQuestionFlowData(questionId: number): {
  flowData: QuestionFlowData | null;
  hasData: boolean;
  isLoading: boolean;
  error: string | null;
} {
  const [flowData, setFlowData] = useState<QuestionFlowData | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const loadData = async () => {
      setIsLoading(true);
      setError(null);
      
      try {
        const data = getQuestionFlowData(questionId);
        setFlowData(data);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Erro ao carregar dados');
      } finally {
        setIsLoading(false);
      }
    };

    loadData();
  }, [questionId]);

  return {
    flowData,
    hasData: !!flowData,
    isLoading,
    error
  };
}